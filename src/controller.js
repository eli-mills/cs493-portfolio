const express = require('express');
const db = require('./model');
const { auth } = require('express-openid-connect');
const {expressjwt: jwt} = require('express-jwt');
const jwksRsa = require('jwks-rsa');
const jwt_decode = require('jwt-decode');
const {wrap} = require('async-middleware');
const DOMAIN = "millse2-cs493-portfolio.us.auth0.com";

// INITIALIZE ROUTERS
const authentication = express.Router();
const boats = express.Router();
const users = express.Router();

/****************************************************************
 *                                                              *
 *                         MIDDLEWARE                           *
 *                                                              *
****************************************************************/

// LIBRARY MIDDLEWARE
const authMiddleware = auth({
    authRequired: false,
    auth0Logout: true,
    baseURL: process.env.NODE_ENV === "production" ? "https://millse2-cs493-portfolio.uk.r.appspot.com" : 'http://localhost:3000',
    issuerBaseURL: `https://${DOMAIN}`
});

const checkJwt = jwt({
    secret: jwksRsa.expressJwtSecret({
      cache: true,
      rateLimit: true,
      jwksRequestsPerMinute: 5,
      jwksUri: `https://${DOMAIN}/.well-known/jwks.json`
    }),
  
    // Validate the audience and the issuer.
    issuer: `https://${DOMAIN}/`,
    algorithms: ['RS256']
  });

// CUSTOM MIDDLEWARE

function getFullBaseUrl(req, id) {
    return `${req.protocol}://${req.get("host")}${req.baseUrl}`;
}

function getEntityFromParams(kind) {
    const middlewareFn = async (req, res, next) => {
        const retrievedEntity = await db.getEntity(kind, req.params.id);
        if (!retrievedEntity) return res.status(404).json({"Error": `No ${kind.toLowerCase()} with this ${kind.toLowerCase()}_id exists.`});
        req.retrievedEntities = [retrievedEntity];
        next();
    }
    return middlewareFn;
}

/**
 * Returns new copy of given object with added self URL.
 * 
 * @param {object} req: the req object generated by express route
 * @param {string} collection: the name of the collection to use in the URL
 * @param {object} objToModify: the object where the self-link will be added
 * @returns {object} copy of object with added self property
 */
function addSelfLinksToResponse(req, res, next) {
    for (const retrievedEntity of req.retrievedEntities) {
        retrievedEntity.self = `${getFullBaseUrl(req)}/${retrievedEntity.id}`;
    }
    
    if (req.retrievedEntities.length === 1) return res.json(req.retrievedEntities[0]);

    return next();
}

function getNextLink(req) {
    const cursor = req.retrievedMetaData.cursor;
    return cursor ? `${getFullBaseUrl(req)}?cursor=${cursor}` : undefined;
}

function addMetaData(req, res, next) {
    const nextLink = getNextLink(req);
    res.json({
        count: req.retrievedMetaData.count,
        next: nextLink,
        data: req.retrievedEntities
    });
}

function assertCorrectOwner(req, res, next) {
    const owner = req.retrievedEntities[0].user;
    if (owner !== req.auth.sub) return res.status(403).json({"Error": "The authorized user does not have access to this boat."});
    return next();
}

function assertAcceptJson(req, res, next) {
    if (!req.accepts("json")) {
        return res.status(406).json({"Error": "Requested MIME type is not supported."});
    }
    return next();
}

function assertContentJson(req, res, next) {
    if (! (req.get("Content-type") === "application/json")) {
        return res.status(415).json({"Error": "Request body contains unsupported MIME type."});
    }
    next();
}

function handleValidationError(err, req, res, next) {
    if (! (err instanceof db.EntityValidationError)) return next(err);
    console.error(err);
    res.status(400).json({"Error": "One or more of the request attributes are missing or invalid."});
}

function methodNotAllowed(req, res) {
    return res.status(405).end();
}

/****************************************************************
 *                                                              *
 *                          ROUTERS                             *
 *                                                              *
****************************************************************/

// AUTHENTICATION
authentication.use(authMiddleware);
authentication.get("/", wrap(async (req, res, next) => {
    if (!req.oidc.isAuthenticated()) {
        return next();         // Use Express static middleware to display login page.
    }
    const decoded = jwt_decode(req.oidc.idToken);
    await db.storeNewEntity("User", {sub: decoded.sub});
    res.status(303).redirect("/user-info");
}));
authentication.get("/user-info", (req, res) => {
    res.json(req.oidc.idToken);
});

// BOATS
boats.route("/")
    .get(checkJwt, wrap(async (req, res, next) => {
        const [usersBoats, cursor, count] = await db.getAllEntities("Boat", req.auth.sub, req.query.cursor);
        req.retrievedEntities = usersBoats;
        req.retrievedMetaData = {cursor, count};

        console.log(cursor);
        res.status(200);
        return next();
    }), addSelfLinksToResponse, addMetaData)
    .post(assertContentJson, assertAcceptJson, checkJwt, wrap(async (req, res, next) => {
        req.body.user = req.auth.sub;
        try {
            const newBoat = await db.storeNewEntity("Boat", req.body);
            req.retrievedEntities = [newBoat];
            res.status(201);
            next();
        } catch (e) {
            next(e);
        }
    }), addSelfLinksToResponse)
    .all(methodNotAllowed);

    boats.route("/:id")
    .all(getEntityFromParams("Boat"))
    .get(checkJwt, assertAcceptJson, assertCorrectOwner, wrap(async (req, res, next) => {
        // Passed all validation...
        res.status(200);
        next();
    }), addSelfLinksToResponse)
    .patch(checkJwt, assertAcceptJson, assertContentJson, wrap(async (req, res, next) => {
        const [retrievedBoat] = req.retrievedEntities;
        try {
            req.retrievedEntities = [await db.updateEntity(retrievedBoat, req.body)];
            if (!req.retrievedEntities[0]) {
                return res.status(500).end();
            }
            res.status(200);
            return next();
        } catch (err) {
            console.log("caught error in patch");
            return next(err);
        }

    }), addSelfLinksToResponse)
    .delete(checkJwt, async (req, res) => {
        const boatToDelete = await db.getEntity("Boat", req.params.boatId);
        if (!boatToDelete || boatToDelete.owner !== req.auth.sub) {
            // ID doesn't exist or owner is unauthorized
            res.status(403).end();
            return;
        }
        db.deleteEntity(boatToDelete);
        res.status(204).end();
    });

boats.use(handleValidationError);

// USERS
users.get("/", async (req, res) => {
    const allUsers = await db.getAllEntities("User");
    res.status(200).json(allUsers);
});

/****************************************************************
 *                                                              *
 *                          EXPORTS                             *
 *                                                              *
****************************************************************/
module.exports = {
    authentication,
    boats,
    users,
}